○ Names of all the partners
Jadon Lai, Mira Shlimenzon, Sarah Hallam

○ An explanation of how well your TinyFS implementation works, including tradeoffs
you made and why.
For our set-up of converting a stereotypical file to a disk (libDisk.c), what we did is we needed to implement a linked list structure to maintain crucial information about each disk such as file pointer, filename of the disk, disk status, and disk size. This choice left us needing to constantly go into the linked list and follow the `next` pointer to find each needed disk. This process was necessary because at runtime we don't know how much disks will be opened and we needed a structure that could grow as needed. Thankfully, for our demo, we are only using one disk: tinyFSDemo. Therefore, this tradeoff is not as important.

Our disk structure that's stored within the file is a series of blocks, each 256 bytes long. In it, we have the blocks setup according to the specs, with the inode block also containing the file's name, size, and creation/modification/access times at specific locations within the "data" portion. Our disk followed a linked block structure. We used the links in each block to point to the next block, depending on the scenario. For instance, the superblock's link points to the start of the free block chain, the inode's link points to the first file extent block, etc. If a block is at the end of it's chain, then its link is 0. This worked well, as we could access each file's file extent blocks easily through the inode block, and could also easily assign free blocks via the free block chain. One downside however is that in order to find a file to open it, we need to search through every block in the disk to check if it's the inode block we want, in addition to our disk having external fragmentation. However, because we're not opening files super frequently and since we fixed the external fragmentation with additional functionality, these downsides aren't super impactful.

The resource table contains a list of open files, with details such as the file's inode, name, file descriptor, file pointer, and read-write bit. The inode was based on the file's inode block number and the file descriptor was based on the index of the file in the resource table. This easily allowed us to check files using the inode, name, and file descriptor. The file pointer was used to read/write bytes, along with seeking to certain points in the file and the read-write bit ensured that we don't write to a file that's read only. Our implementation of the resource table worked very well, and we didn't make any tradeoffs.

○ An explanation of which additional functionality areas you have chosen and how
you have shown that it works.
For our TinyFS implementation, we added additional functionality in four different areas: timestamps, read-only and writeByte support, fragmentation info and defragmentation, and directory listing and file renaming.

For our timestamps, what we did is we added three times to the inode's data, alongside the name and size of the file. Here we added a creation time, modification time, and access time. Anytime, we would read or write into a file we would rewrite the inode block to have the updated access or modification time. The creation time is set when we first create the file with tfs_openFile(), and doesn't change at all. We created a print function that allowed us, with a given file descriptor (aka file), to print out all the file's times, along with the file's block link, name, and size. This works because in our tinyFSDemo, when we create a file, the creation/modification/access times are all the same, and after waiting 3 seconds, we write to the file. This appropriately changes the modification/access times, and once we run tinyFSDemo again to read the files, the access times are also appropriately changed. We can see this information using our print function that we created for files.

For read-only and writeByte support, we added a bit to the resource table that displayed whether the open file is read-only or read-write. This made it easy to check in other functions so that we don't accidentally write to a read-only file. The writeByte was also trivial, similar to readByte, but instead of reading in the byte, we check if the file is read-write, then write the given byte to the correct block in the disk, and finally increment the file pointer by 1. This works because in our tinyFSDemo, because before reading all the bytes from afile, we set it to read only and try to write the integer 9. This correctly returns an error, and when we change afile to read-write and try to write 9 again, it correctly writes the byte 9 and prints it out when we print the bytes of the file (after seeking back 1 to actually read the 9 that we just wrote, since writing increments the file pointer).

For fragmentation info, we print out the disk with details such as each block's number, type, and link. This allows us to see the free block chain, where fragmentation occurs in the disk, and how file blocks are linked together. In our defragmentation function, we iterate through the entire disk (except the superblock), saving all the inode and file extent blocks. Then, we reinitialize the disk to just a superblock and free blocks, where the superblock points to the start of the newly created free block chain. After this, we rewrite the inode and file extent blocks to the disk, ensuring that they're correctly linked together. This works because in our tinyFSDemo, after the second run, we have deleted afile, but kept cfile and bfile. This leads to fragmentation in our disk, since afile was created first, and now the blocks 1 and 2 are open and added to the free block chain. We can see this from our fragmentation info function, and after fixing the fragmentation with our defragmentation function, we can see that the cfile and bfile are now correctly at the "top" of the disk, right below the superblock, and the free block list starts at the end of the files.

For file renaming, we check that we have write permissions and that the file is open. After this, we access the inode block via the resource table, rewrite the name using the given name, and rewrite the inode block to the disk. We also change the name in the resource table.
To list the root directory, we iterate through the entire disk, and every time we come across an inode block, we print out the name of the file using the name that's inside of the data of the inode block. This works because in our tinyFSDemo, when we initially create afile and print out the directory, our readdir correctly prints out just afile. Then, when we create bfile, our readdir correctly prints out both afile and bfile. Then, we rename bfile to cfile, and when running tinyFSDemo again, it correctly prints out cfile after deleting afile, since cfile still exists in the disk, but afile doesn't.

○ Any limitations or bugs your file system has.
We do not have any limitations or bugs in our file system. It is looking good. 

